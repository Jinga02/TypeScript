# 함수 오버로딩

함수 오버로딩은 하나의 함수를 매개변수의 개수나 타입에 따라 여러 가지 버전으로 만드는 문법이다.
이를 통해 동일한 함수 이름을 사용하면서 다양한 매개변수에 대한 처리를 구현할 수 있다.

예를 들어, `func`이라는 함수를 예시로 들어보자.
이 함수는 모든 매개변수의 타입이 숫자(number)인 경우를 다루고 있다. 함수 `func`의 오버로딩 버전은 다음과 같다.

- Ver1. 매개변수가 1개인 경우: 매개변수에 20을 곱한 값을 출력한다.
- Ver2. 매개변수가 3개인 경우: 매개변수들을 모두 더한 값을 출력한다.

아래는 TypeScript로 작성된 함수 `func`의 오버로딩 예시이다.

```ts
// 함수의 구현부 없이 선언식만 써놓은 것을 오버로드 시그니처(overload signature)라고 한다.

// - 오버로드 시그니처
function func(a: number): void;
function func(a: number, b: number, c: number): void;

// 실제 구현부 - 구현 시그니처

func(1); // 에러 없음
func(1, 2); // 에러 발생
func(1, 2, 3); // 에러 없음

function func(a: number, b: number, c: number) {} // 이 부분은 에러가 발생한다.

function func(a: number, b?: number, c?: number) {
  // 이 부분은 에러가 발생하지 않습니다.
  if (typeof b === "number" && typeof c === "number") {
    console.log(a + b + c);
  } else {
    console.log(a * 20);
  }
}
```

위의 코드에서 `func` 함수는 오버로드 시그니처로 선언되어 있으며, 구체적인 구현은 나중에 작성된다.
오버로드 시그니처는 함수의 정의를 나타내는 부분으로, 함수 이름과 매개변수의 개수와 타입을 정의한다. 이후에 실제 구현 부분인 구현 시그니처가 작성된다.

`func` 함수를 호출할 때는 매개변수의 개수와 타입에 따라 오버로드된 버전 중에서 알맞은 버전이 선택된다. 첫 번째 호출인 `func(1)`은 매개변수가 1개인 경우에 해당하므로, 20을 곱한 값을 출력하게 된다. 두 번째 호출인 `func(1, 2)`는 오버로드된 버전이 없기 때문에 에러가 발생한다. 세 번째 호출인 `func(1, 2, 3)`은 매개변수가 3개인 경우에 해당하므로, 매개변수들을 모두 더한 값을 출력하게 된다.

마지막으로, `func` 함수의 실제 구현 부분은 매개변수 `b`와 `c`가 선택적 매개변수(optional parameter)로 선언되어 있다. 이는 매개변수 `b`와 `c`가 존재하지 않을 수도 있다는 의미이다. 따라서, `b`와 `c`의 타입을 확인하여 모두 숫자인 경우에는 매개변수들을 모두 더한 값을 출력하고, 그렇지 않은 경우에는 매개변수 `a`에 20을 곱한 값을 출력한다.

이처럼 함수 오버로딩은 매개변수의 개수나 타입에 따라 다양한 동작을 구현할 수 있어 유용하게 활용된다.
